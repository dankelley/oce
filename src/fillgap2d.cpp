/* vim: set expandtab shiftwidth=2 softtabstop=2 tw=70: */

#include <Rcpp.h>
using namespace Rcpp;

// Cross-reference work:
// 1. update ../src/registerDynamicSymbol.c with an item for this
// 2. main code should use the autogenerated wrapper in ../R/RcppExports.R
//
// [[Rcpp::export]]
NumericMatrix do_fill_gap_2d(NumericMatrix m, IntegerVector Span,
                             IntegerVector Debug) {
  int spanRow = Span[0];
  int spanCol = Span[1];
  int debug = Debug[0];
  if (debug) {
    Rprintf("span=c(%d, %d) so spanRow=%d and spanCol=%d\n", Span[0], Span[1],
            spanRow, spanCol);
  }
  int ncol = m.ncol();
  int nrow = m.nrow();
  // Rprintf("nrow=%d\n", nrow);
  NumericMatrix r(m); // initialize return value to input value
  int N = 0;
  double SUM = 0.0;
  int im, ip, jm, jp;
  for (int i = 0; i < nrow - 1; i++) {
    for (int j = 0; j < ncol - 1; j++) {
      // Rprintf("m[%d,%d] is %g\n", i + 1, j + 1, m(i, j));
      if (ISNA(m(i, j))) {
        if (debug) {
          Rprintf("m[%d,%d] is %g\n", i + 1, j + 1, m(i, j));
        }
        // find im,ip (indices of good neighbours in i), and similarly jm,jp
        for (im = i - 1; im > -1; im--) {
          if (debug) {
            Rprintf("  trial im=%d\n", im + 1);
          }
          if (!ISNA(m(im, j))) {
            break; // this defines im (<i)
          }
        }
        if (debug) {
          Rprintf("  got im=%d (in R index-1 notation)\n", im + 1);
        }
        for (jm = j - 1; jm > -1; jm--) {
          if (debug) {
            Rprintf("  trial jm=%d\n", jm + 1);
          }
          if (!ISNA(m(i, jm))) {
            break; // this defines jm (<j)
          }
        }
        if (debug) {
          Rprintf("  got jm=%d (in R index-1 notation)\n", jm + 1);
        }
        // FIXME: is the limit correct on next ... maybe nxbreaks-1 ???
        for (ip = i + 1; ip < nrow; ip++) {
          if (debug) {
            Rprintf("  trial ip=%d\n", ip + 1);
          }
          if (!ISNA(m(ip, j))) {
            break; // this defines ip (>i)
          }
        }
        if (debug) {
          Rprintf("  got ip=%d (in R index-1 notation)\n", ip + 1);
        }
        for (jp = j + 1; jp < ncol; jp++) {
          if (debug) {
            Rprintf("  trial jp=%d\n", jp + 1);
          }
          if (!ISNA(m(i, jp))) {
            break; // this defines jp (>j)
          }
        }
        if (debug) {
          Rprintf("  got jp=%d (in R index-1 notation)\n", jp + 1);
        }
        // can only fill if good neighbours exist (not at edges)
        N = 0;
        SUM = 0.0;
        if (0 <= im && ip <= nrow - 1) {
          if (debug) {
            Rprintf("  can we interpolate from im=%d to ip=%d?\n", im + 1,
                    ip + 1);
            if ((ip - im) <= spanRow) {
              if (debug) {
                Rprintf("  long enough since spanCol=%d\n", spanCol);
              }
              double M =
                  m(im, j) + (m(ip, j) - m(im, j)) * (i - im) / (ip - im);
              SUM += M;
              N++;
              if (debug) {
                Rprintf("m[%d,%d]=NA but m[c(%d,%d),%d]=(%.4g,%.4g) "
                        "so interpolating to %.4g\n",
                        i + 1, j + 1, im + 1, ip + 1, j + 1, m(im, j), m(ip, j),
                        M);
              }
            }
          }
          if (0 <= jm && jp <= ncol - 1) {
            if (debug) {
              Rprintf("  can we interpolate from jm=%d to jp=%d?\n", jm + 1,
                      jp + 1);
            }
          }
          if ((jp - jm) <= spanCol) {
            if (debug) {
              Rprintf("  long enough since spanRow=%d\n", spanRow);
            }
            double M = m(i, jm) + (m(i, jp) - m(i, jm)) * (j - jm) / (jp - jm);
            SUM += M;
            N++;
            if (debug) {
              Rprintf("m[%d,%d]=NA but m[%d,c(%d,%d)]=(%.4g,%.4g) "
                      "so interpolating to %.4g\n",
                      i + 1, j + 1, i + 1, jm + 1, jp + 1, m(i, jm), m(i, jp),
                      M);
            }
          }
        }
        if (N > 0) {
          r(i, j) = SUM / N;
          if (debug) {
            Rprintf("setting return value r[%d,%d] to %.4g\n", i + 1, j + 1,
                    r(i, j));
          }
        }
      }
    }
  }
  return (r);
}
